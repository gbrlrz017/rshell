-list known bugs: 
	- To exit my rshell program, must type "exit" exactly, no white space. 
		~"      exit" or "exit    " or "   exit    " do not work.
	- when entering " ; pwd" runs pwd instead of failing 
		bc '; ' not a command like bash does. 
	- cannot run for loop in my rshell terminal, so cannot run many commands at same time
		~ cannot run "pwd && pwd .....&& pwd" 10000 times
		~ I'm sure if I typed all 10000 commands down then it would work (too inefficient though)
		~ So Did not test this.




-summarize project:
	- A basic bash terminal that is able to run any command with any arguments passed that are in ./bin
	- There are a few cases where this program fails (namely those listed above)
	- Code: 
		~ user inputs commands into pseudo-terminal. Input is saved in c++ std::string
		~ Input is then parsed accordingly, using " &&;||" as delimiters
		~ Program then runs for child/parent processes
		~ commands are executed in execvp, which is called during child process
		~ parent process waits for child
		~ Fork is called in a loop so after child exits, the parent continues the looping
		~ Fork is in loop to handle case of multiple args w/connectors && || ;
		~ Entire program is in a while loop, which keeps the "$" prompt going
			to keep receiving user input. 
		~ Program is terminated with input of "exit" (see bugs for this special case)











Figuring out way to handle cases with connectors: && || ;

pseudo-code: 
//pass in code through std::string
//did this to read in using getline(cin, std::string ) (probably alternatives)

//copy std::string used for input to cstring 
//(used strcpy to deal with conversion from const char* (input.c_str()) to char*)
//probably a better way

//I then tokenize all the input and place it in char** argv (have var called tmp)
//tokenizer function is strtok
//using " &&||;" as delimiters (but do I need to do this??)
//left with same input, minus the connectors
// do this in while loop

//call fork and make sure no error (that doesn't return -1)
//in child: 
    //is where I'm calling execvp
    //however, only works for one call not any with connectors
//parent waits for child. Is it supposed to execute anything or just wait? 

//remember case with # comments!


//possible new parsing method: 
//see: strstr function

    1. find occurrence of && || or ; 
    2. Anything before this connector is now an unparsed/untokenized argv1
    3. Anything after this is now an unparsed/untokenized argv2
    4. Repeat steps 1-3 as neccessary to create argv'i' for i = {1, 2, ..., n}
        for n necessary inputted commands. 
 
    QUESTION: How to declare new argv'i'? 
    ANSWER (potentially): declare "big" char* args [9999]?
    OR: count the number of occurences of connecters in input (DUH)
        then declare (maybe not as big) char* args [n+1]
        ~this could get ugly~
        -each element will contain one unparsed/untokenized argv'i'

    5. Parse/tokenize each argv'i' 


    6. Call fork and execute execvp in 1st child




